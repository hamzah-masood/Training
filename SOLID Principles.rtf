{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red10\green10\blue11;
\red46\green56\blue61;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c3549\c3944\c4323;
\cssrgb\c23670\c28393\c30657;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\tx720\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 Solid stands for: \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Single Responsibility Principle\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Open/closed Principle\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Liskov Substitution Principle\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Interface Segregation Principle\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Dependency Inversion Principle\
\pard\tx720\pardeftab720\partightenfactor0
\cf2 \
These are not only good principles for Object Oriented Programming, but for programming in general too.\
\
\
SRP is the most important principle, basically it says that every class should have one responsibility and reason to change. It should do no more and no less than that one responsibility. It only changes when it structurally needs to be changed.\
\
OCP means that when writing code, you should extend the behavior of objects through inheritance, polymorphism and composition by implementing them using interfaces, abstractions and dependency injections. Essentially, extending the classes behavior without modifying it, so the initial class can be used same without it being changed completely.\
\
LS is where objects should be replaceable with instances of their subtype, without change the correctness of the program. Decorator design patter is a wrapper around another class to enhance its capabilities. So basically we can wrap our object in multiple decorators and used them like the objects they decorate as they comply to the same protocol. \
\
IS instructs developers to make fine grained interacts that are client-specific. Basically have interfaces with single responsibility to make sure you are not forcing your class which conforms to protocols to implement unwanted requirements that were not required. \
\
DI is where high level modules should not depend on low level modules, both should depend on abstraction. Using protocols we make sure high level modules aren\'92t coupled tightly with low level modules.}